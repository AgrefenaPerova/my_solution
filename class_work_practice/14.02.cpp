//дан отрезок, найди подотрезок в котором мин*макс=мин
/*
1) пишем стек
2) пишем стек с поддержкой минимума или максимума (за 0(1) находим мин в любой момент)
дз 
   1) очередь на двух стеках
   --пушить только в первый стек, поп во второй стек(если не пустой) иначе из первого поп пуш во второй
   2) написать очередь на закольцованном массиве (если элементы закончились в начало добавлять и энд в начало)
   3) 1136 стек и бинарнрое дерево. рекурсивное создание дерева! (обход бинарного дерева)
   4) 1992
*/
#include<iostream>
#include"Node.h"
#include"Stack.h"
int main() {
	Stack* st = new Stack(4);
	st->Push(3);
	st->Push(10);
	st->View();
	std::cout << st->Min() << std::endl;
	int a=st->Pop();
	std::cout << a << ' ';
	std::cout << st->Min() << std::endl;
	return 0;
}